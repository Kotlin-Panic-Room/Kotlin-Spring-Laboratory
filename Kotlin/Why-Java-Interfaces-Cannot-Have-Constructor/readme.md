생성자는 새로 만든 개체를 초기화하는 데 사용되는 특수 멤버 함수입니다. 클래스의 개체가 생성되면 자동으로 호출됩니다.

### 인터페이스에 생성자를 사용할 수 없는 이유는 무엇일까요?

* 인터페이스는 클래스의 완전한 추상화입니다. 인터페이스에 있는 모든 데이터 멤버는 기본적으로 public, satic 및 final입니다. 선언할 때 모든 static final 필드에 값을 할당해야 합니다. 그렇지 않으면 "variable variable_Name not initialized in default constructor"라는 컴파일 오류가 발생합니다.
* 인터페이스 내부의 메소드는 기본적으로 공개 추상화이며, 이는 메소드 구현이 인터페이스 자체에 의해 제공될 수 없으며, 구현 클래스에 의해 제공되어야 한다는 것을 의미합니다. 따라서 인터페이스 내부에 생성자를 둘 필요가 없습니다.
* 생성자는 비정적 데이터 멤버를 초기화하는 데 사용되며 인터페이스에 비정적 데이터 멤버가 없으므로 생성자가 필요하지 않습니다.
* 인터페이스에 존재하는 메소드는 정의되지 않은 것으로 선언될 뿐이며, 메소드의 구현이 없기 때문에 인터페이스에 호출 메서드를 위한 오브젝트를 만들 필요가 없기 때문에 생성자를 가질 필요가 없습니다.
* 만약 우리가 인터페이스 안에 생성자를 만들려고 한다면 컴파일러는 컴파일 타임 에러를 줄 것입니다.


```kotlin

interface Subtraction {
    // 기본 값으로 메소드를 만든다.
    // 추상 메소드
    fun subtract(a: Int, b: Int): Int
} // 구현으로 클래스 만들기

class Cozak : Subtraction {
    // Defining subtract method
    override fun subtract(a: Int, b: Int): Int {
        return a - b
    }

    companion object {
        // Driver Code
        @JvmStatic
        fun main(args: Array<String>) {
            // Cozak 인스턴스 생성
            val g = Cozak()
            println(g.subtract(20, 5))
        }
    }
}
```

위의 프로그램에서, 우리는 Cozak 클래스에서 구현이 제공되는 메서드 뺄셈()을 정의하는 인터페이스 뺄셈을 만들었습니다. 메소드를 호출하기 위해서는 오브젝트를 만들어야 하는데, 인터페이스 내부의 메소드는 기본적으로 본문을 가지고 있지 않다는 것을 의미하는 공개 추상화(public abstract)이기 때문이다. 

따라서 인터페이스에서 메서드를 호출할 필요가 없습니다. 인터페이스에서 메소드를 호출할 수 없기 때문에 인터페이스를 위한 오브젝트를 만들 필요가 없고 생성자를 가질 필요도 없습니다.

### 추상 클래스는 왜 생성자를 가질까요?

* 생성자의 주요 목적은 새로 생성된 개체를 초기화하는 것입니다. 추상 클래스에서는 인스턴스 변수, 추상적 방법 및 비추상적 방법이 있습니다. 우리는 비추상 방법과 인스턴스 변수를 초기화해야 하므로 추상 클래스는 생성자를 가지고 있습니다.
* 또한 생성자를 제공하지 않더라도 컴파일러는 기본 생성자를 추상 클래스에 추가합니다.
* 추상 클래스는 임의의 수의 하위 클래스에서 상속될 수 있으므로 추상 클래스에 있는 생성자의 기능을 사용할 수 있습니다.
* 추상 클래스 내부의 생성자는 생성자 체인 중에만 호출될 수 있습니다. 즉, 하위 클래스의 인스턴스를 만들 때 호출할 수 있습니다. 이것은 또한 추상 클래스가 생성자를 가질 수 있는 이유 중 하나입니다.


```kotlin
abstract class Car {
    init {
        println("car is created")
    }
} 

class Maruti : Car() {
    fun run() {
        println("Maruti is running")
    }
}

object GFG {
    @JvmStatic
    fun main(args: Array<String>) {
        val c = Maruti()
        c.run()
    }
}
```
